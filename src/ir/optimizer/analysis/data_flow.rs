//! Data Flow Analysis Framework
//!
//! This module provides a generic framework for implementing data flow analyses
//! such as liveness analysis, available expressions, and reaching definitions.

use super::control_flow::ControlFlowGraph;
use crate::ir::{BlockId, Function};
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::hash::Hash;

/// Direction of data flow analysis
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DataFlowDirection {
    /// Forward analysis (information flows from predecessors to successors)
    Forward,
    /// Backward analysis (information flows from successors to predecessors)
    Backward,
}

/// Join operation for combining data flow sets
pub trait DataFlowJoin<T> {
    /// Join two sets (e.g., union for may-analysis, intersection for must-analysis)
    fn join(&self, a: &T, b: &T) -> T;

    /// Identity element for the join operation
    fn identity(&self) -> T;
}

/// Transfer function for data flow analysis
pub trait DataFlowTransfer<T> {
    /// Apply the transfer function to a basic block
    /// Returns (gen_set, kill_set) where:
    /// - gen_set: information generated by this block
    /// - kill_set: information killed by this block
    fn transfer(&self, block_id: BlockId, func: &Function) -> (T, T);
}

/// Data flow problem definition
pub trait DataFlowProblem<T>: DataFlowJoin<T> + DataFlowTransfer<T>
where
    T: Clone + PartialEq + fmt::Debug,
{
    /// Get the direction of this analysis
    fn direction(&self) -> DataFlowDirection;

    /// Get the name of this analysis
    fn name(&self) -> &'static str;

    /// Apply the data flow equation: OUT = (IN - KILL) ∪ GEN
    fn apply_equation(&self, in_set: &T, gen_set: &T, kill_set: &T) -> T;
}

/// Data flow analysis result
#[derive(Debug, Clone)]
pub struct DataFlowResult<T> {
    /// IN sets for each block
    pub in_sets: HashMap<BlockId, T>,
    /// OUT sets for each block
    pub out_sets: HashMap<BlockId, T>,
    /// GEN sets for each block
    pub gen_sets: HashMap<BlockId, T>,
    /// KILL sets for each block
    pub kill_sets: HashMap<BlockId, T>,
    /// Number of iterations taken to converge
    pub iterations: usize,
}

impl<T> DataFlowResult<T> {
    /// Create a new empty result
    pub fn new() -> Self {
        DataFlowResult {
            in_sets: HashMap::new(),
            out_sets: HashMap::new(),
            gen_sets: HashMap::new(),
            kill_sets: HashMap::new(),
            iterations: 0,
        }
    }

    /// Get the IN set for a block
    pub fn get_in(&self, block: BlockId) -> Option<&T> {
        self.in_sets.get(&block)
    }

    /// Get the OUT set for a block
    pub fn get_out(&self, block: BlockId) -> Option<&T> {
        self.out_sets.get(&block)
    }

    /// Get the GEN set for a block
    pub fn get_gen(&self, block: BlockId) -> Option<&T> {
        self.gen_sets.get(&block)
    }

    /// Get the KILL set for a block
    pub fn get_kill(&self, block: BlockId) -> Option<&T> {
        self.kill_sets.get(&block)
    }
}

impl<T> Default for DataFlowResult<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Generic data flow analysis solver
pub struct DataFlowSolver {
    /// Maximum number of iterations before giving up
    max_iterations: usize,
    /// Whether to enable debug output
    debug: bool,
}

impl DataFlowSolver {
    /// Create a new data flow solver
    pub fn new() -> Self {
        DataFlowSolver {
            max_iterations: 100,
            debug: false,
        }
    }

    /// Set maximum iterations
    pub fn set_max_iterations(&mut self, max: usize) {
        self.max_iterations = max;
    }

    /// Enable debug output
    pub fn enable_debug(&mut self) {
        self.debug = true;
    }

    /// Solve a data flow problem
    pub fn solve<T, P>(
        &mut self,
        problem: &P,
        func: &Function,
        cfg: &ControlFlowGraph,
    ) -> DataFlowResult<T>
    where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        let mut result = DataFlowResult::new();

        if self.debug {
            eprintln!(
                "Solving {} analysis ({})",
                problem.name(),
                match problem.direction() {
                    DataFlowDirection::Forward => "forward",
                    DataFlowDirection::Backward => "backward",
                }
            );
        }

        // Step 1: Compute GEN and KILL sets for each block
        self.compute_gen_kill_sets(problem, func, &mut result);

        // Step 2: Initialize IN and OUT sets
        self.initialize_sets(problem, cfg, &mut result);

        // Step 3: Iterative analysis until convergence
        self.iterative_analysis(problem, func, cfg, &mut result);

        if self.debug {
            eprintln!("  Converged in {} iterations", result.iterations);
        }

        result
    }

    /// Compute GEN and KILL sets for each block
    fn compute_gen_kill_sets<T, P>(
        &self,
        problem: &P,
        func: &Function,
        result: &mut DataFlowResult<T>,
    ) where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        for (block_id, _) in func.blocks() {
            let (gen_set, kill_set) = problem.transfer(*block_id, func);
            result.gen_sets.insert(*block_id, gen_set);
            result.kill_sets.insert(*block_id, kill_set);
        }
    }

    /// Initialize IN and OUT sets
    fn initialize_sets<T, P>(
        &self,
        problem: &P,
        cfg: &ControlFlowGraph,
        result: &mut DataFlowResult<T>,
    ) where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        let identity = problem.identity();

        for &block_id in cfg.nodes.keys() {
            result.in_sets.insert(block_id, identity.clone());
            result.out_sets.insert(block_id, identity.clone());
        }
    }

    /// Run iterative analysis until convergence
    fn iterative_analysis<T, P>(
        &self,
        problem: &P,
        func: &Function,
        cfg: &ControlFlowGraph,
        result: &mut DataFlowResult<T>,
    ) where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        let mut changed = true;
        let mut iteration = 0;

        // Get blocks in appropriate order
        let blocks = match problem.direction() {
            DataFlowDirection::Forward => cfg.reverse_post_order(),
            DataFlowDirection::Backward => {
                let mut rpo = cfg.reverse_post_order();
                rpo.reverse();
                rpo
            }
        };

        while changed && iteration < self.max_iterations {
            changed = false;
            iteration += 1;

            if self.debug && iteration % 10 == 0 {
                eprintln!("  Iteration {}", iteration);
            }

            for &block_id in &blocks {
                let old_in = result
                    .in_sets
                    .get(&block_id)
                    .cloned()
                    .unwrap_or_else(|| problem.identity());
                let old_out = result
                    .out_sets
                    .get(&block_id)
                    .cloned()
                    .unwrap_or_else(|| problem.identity());

                // Compute new IN set
                let new_in = match problem.direction() {
                    DataFlowDirection::Forward => {
                        // IN[B] = ∪ OUT[P] for all predecessors P
                        let predecessors = cfg.predecessors(block_id);
                        self.join_predecessor_sets(problem, &predecessors, &result.out_sets)
                    }
                    DataFlowDirection::Backward => {
                        // IN[B] = ∪ OUT[S] for all successors S
                        let successors = cfg.successors(block_id);
                        self.join_successor_sets(problem, &successors, &result.out_sets)
                    }
                };

                // Compute new OUT set using transfer function
                let gen_set = result
                    .gen_sets
                    .get(&block_id)
                    .cloned()
                    .unwrap_or_else(|| problem.identity());
                let kill_set = result
                    .kill_sets
                    .get(&block_id)
                    .cloned()
                    .unwrap_or_else(|| problem.identity());
                let new_out = problem.apply_equation(&new_in, &gen_set, &kill_set);

                // Check for changes
                if new_in != old_in || new_out != old_out {
                    changed = true;
                    result.in_sets.insert(block_id, new_in);
                    result.out_sets.insert(block_id, new_out);
                }
            }
        }

        result.iterations = iteration;

        if iteration >= self.max_iterations {
            eprintln!(
                "Warning: {} analysis did not converge in {} iterations",
                problem.name(),
                self.max_iterations
            );
        }
    }

    /// Join sets from predecessors
    fn join_predecessor_sets<T, P>(
        &self,
        problem: &P,
        predecessors: &[BlockId],
        out_sets: &HashMap<BlockId, T>,
    ) -> T
    where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        if predecessors.is_empty() {
            return problem.identity();
        }

        let mut result = problem.identity();
        for &pred in predecessors {
            if let Some(pred_out) = out_sets.get(&pred) {
                result = problem.join(&result, pred_out);
            }
        }
        result
    }

    /// Join sets from successors
    fn join_successor_sets<T, P>(
        &self,
        problem: &P,
        successors: &[BlockId],
        out_sets: &HashMap<BlockId, T>,
    ) -> T
    where
        T: Clone + PartialEq + fmt::Debug,
        P: DataFlowProblem<T>,
    {
        if successors.is_empty() {
            return problem.identity();
        }

        let mut result = problem.identity();
        for &succ in successors {
            if let Some(succ_out) = out_sets.get(&succ) {
                result = problem.join(&result, succ_out);
            }
        }
        result
    }
}

impl Default for DataFlowSolver {
    fn default() -> Self {
        Self::new()
    }
}

/// Data flow analysis trait for easy implementation
pub trait DataFlowAnalysis<T>
where
    T: Clone + PartialEq + fmt::Debug,
{
    /// The data flow problem this analysis solves
    type Problem: DataFlowProblem<T>;

    /// Create the data flow problem
    fn create_problem(&self) -> Self::Problem;

    /// Run the analysis on a function
    fn analyze(&mut self, func: &Function, cfg: &ControlFlowGraph) -> DataFlowResult<T> {
        let problem = self.create_problem();
        let mut solver = DataFlowSolver::new();
        solver.solve(&problem, func, cfg)
    }
}

// Example implementations of common join operations

/// Union join operation (for may-analysis)
#[derive(Debug, Clone)]
pub struct UnionJoin;

impl<T> DataFlowJoin<HashSet<T>> for UnionJoin
where
    T: Clone + Eq + Hash,
{
    fn join(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.union(b).cloned().collect()
    }

    fn identity(&self) -> HashSet<T> {
        HashSet::new()
    }
}

/// Intersection join operation (for must-analysis)
#[derive(Debug, Clone)]
pub struct IntersectionJoin;

impl<T> DataFlowJoin<HashSet<T>> for IntersectionJoin
where
    T: Clone + Eq + Hash,
{
    fn join(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        if a.is_empty() {
            b.clone()
        } else if b.is_empty() {
            a.clone()
        } else {
            a.intersection(b).cloned().collect()
        }
    }

    fn identity(&self) -> HashSet<T> {
        HashSet::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{BinaryOp, Constant, Instruction, IrBuilder, ValueId};
    use crate::types::Type;

    // Example data flow problem: available expressions
    #[derive(Debug, Clone)]
    struct AvailableExpressions;

    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    struct Expression {
        op: String,
        left: ValueId,
        right: ValueId,
    }

    impl DataFlowJoin<HashSet<Expression>> for AvailableExpressions {
        fn join(&self, a: &HashSet<Expression>, b: &HashSet<Expression>) -> HashSet<Expression> {
            a.intersection(b).cloned().collect()
        }

        fn identity(&self) -> HashSet<Expression> {
            HashSet::new()
        }
    }

    impl DataFlowTransfer<HashSet<Expression>> for AvailableExpressions {
        fn transfer(
            &self,
            block_id: BlockId,
            func: &Function,
        ) -> (HashSet<Expression>, HashSet<Expression>) {
            let mut gen_set = HashSet::new();
            let mut kill_set = HashSet::new();

            if let Some(block) = func.get_block(block_id) {
                for (value_id, inst_with_loc) in &block.instructions {
                    match &inst_with_loc.instruction {
                        Instruction::Binary { op, lhs, rhs, .. } => {
                            let expr = Expression {
                                op: format!("{:?}", op),
                                left: *lhs,
                                right: *rhs,
                            };
                            gen_set.insert(expr);

                            // Kill expressions that use this value
                            // (Simplified - real implementation would be more complex)
                        }
                        _ => {}
                    }
                }
            }

            (gen_set, kill_set)
        }
    }

    impl DataFlowProblem<HashSet<Expression>> for AvailableExpressions {
        fn direction(&self) -> DataFlowDirection {
            DataFlowDirection::Forward
        }

        fn name(&self) -> &'static str {
            "Available Expressions"
        }

        fn apply_equation(
            &self,
            in_set: &HashSet<Expression>,
            gen_set: &HashSet<Expression>,
            kill_set: &HashSet<Expression>,
        ) -> HashSet<Expression> {
            let mut result = in_set.clone();
            // Remove killed expressions
            for expr in kill_set {
                result.remove(expr);
            }
            // Add generated expressions
            result.extend(gen_set.clone());
            result
        }
    }

    #[test]
    fn test_data_flow_solver() {
        let mut builder = IrBuilder::new();

        // Create a simple function for testing
        let func_id = builder.create_function("test".to_string(), vec![], Type::I32);

        let entry = builder.get_current_block().unwrap();
        builder.set_current_block(entry);

        let a = builder.const_value(Constant::I32(1));
        let b = builder.const_value(Constant::I32(2));
        let c = builder
            .build_binary(BinaryOp::Add, a, b, Type::I32)
            .unwrap();
        builder.build_return(Some(c));

        // Build CFG and run analysis
        let module = builder.build();
        let func = module.get_function(func_id).unwrap();
        let cfg = ControlFlowGraph::build(func);

        let problem = AvailableExpressions;
        let mut solver = DataFlowSolver::new();
        let result = solver.solve(&problem, func, &cfg);

        // Check that analysis completed
        assert!(result.iterations > 0);
        assert!(!result.in_sets.is_empty());
        assert!(!result.out_sets.is_empty());
    }

    #[test]
    fn test_union_join() {
        let join_op = UnionJoin;

        let mut set_a = HashSet::new();
        set_a.insert(1);
        set_a.insert(2);

        let mut set_b = HashSet::new();
        set_b.insert(2);
        set_b.insert(3);

        let result = join_op.join(&set_a, &set_b);

        assert_eq!(result.len(), 3);
        assert!(result.contains(&1));
        assert!(result.contains(&2));
        assert!(result.contains(&3));

        let identity: std::collections::HashSet<i32> = join_op.identity();
        assert!(identity.is_empty());
    }

    #[test]
    fn test_intersection_join() {
        let join_op = IntersectionJoin;

        let mut set_a = HashSet::new();
        set_a.insert(1);
        set_a.insert(2);
        set_a.insert(3);

        let mut set_b = HashSet::new();
        set_b.insert(2);
        set_b.insert(3);
        set_b.insert(4);

        let result = join_op.join(&set_a, &set_b);

        assert_eq!(result.len(), 2);
        assert!(result.contains(&2));
        assert!(result.contains(&3));

        let identity: std::collections::HashSet<i32> = join_op.identity();
        assert!(identity.is_empty());
    }
}
