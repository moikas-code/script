//! Runtime system for the Script programming language
//!
//! This module provides the core runtime functionality including:
//! - Reference counting memory management with cycle detection
//! - Runtime initialization and shutdown
//! - Panic handling with stack traces
//! - Memory profiling and leak detection
//!
//! The runtime is designed to be thread-safe for future actor model support
//! and integrates with the code generated by the IR system.

pub mod async_ffi;
pub mod async_ffi_secure;
pub mod async_generators;
pub mod async_resource_limits;
pub mod async_runtime;
pub mod async_runtime_secure;
// pub mod async_security_tests; // Temporarily disabled for compilation
pub mod async_tokio_bridge;
pub mod closure;
pub mod core;
pub mod distributed;
pub mod gc;
pub mod method_dispatch;
pub mod optimized_value;
pub mod panic;
pub mod profiler;
pub mod rc;
pub mod recovery;
pub mod resource_limits;
pub mod safe_gc;
pub mod sandbox;
pub mod scheduler;
pub mod security;
pub mod stack_trace;
pub mod traceable;
pub mod type_registry;
pub mod value;
pub mod value_conversion;

pub use async_generators::{AsyncGenerator, AsyncGeneratorNext, AsyncGeneratorRuntime};
pub use async_runtime::{BoxedFuture, Executor, ScriptFuture, TaskId, Timer};
pub use async_tokio_bridge::{
    block_on as tokio_block_on, global_runtime, init_global_runtime, spawn as tokio_spawn,
    TokioBridge, TokioConfig,
};
pub use closure::{
    create_closure_optimal, create_optimized_closure_heap, create_simple_closure,
    get_performance_config, get_performance_stats, reset_performance_stats, set_performance_config,
    Closure, ClosurePerformanceConfig, ClosurePerformanceStats, ClosureRuntime, OptimizedClosure,
    OptimizedClosureRuntime,
};
pub use core::{Runtime, RuntimeConfig};
pub use distributed::{DistributedNode, DistributedScheduler, LoadBalancingStrategy};
pub use gc::CycleCollector;
pub use method_dispatch::{get_method_dispatcher, MethodDispatcher};
pub use panic::{PanicHandler, RecoveryContext, RecoveryPolicy, RecoveryResult};
pub use profiler::{AllocationStats, MemoryProfiler};
pub use rc::{ScriptRc, ScriptWeak};
pub use recovery::{RecoveryMetrics, RuntimeState, StateRecoveryManager, ValidationResult};
pub use resource_limits::{ResourceLimits, ResourceMonitor, ResourceViolation};
pub use safe_gc::{GcSecurityConfig, SecureCycleCollector, SecurityError as GcSecurityError};
pub use sandbox::{Capability, Sandbox, SandboxConfig, SandboxManager, SecurityViolation};
pub use scheduler::{Scheduler, Task};
pub use security::{SecurityConfig, SecurityEvent, SecurityEventType, SecurityMonitor};
pub use stack_trace::{
    capture_current_trace, get_stack_tracker, initialize_stack_tracker, RuntimeStackTracker,
    StackFrame, StackGuard, StackTrace, StackTraceBuilder, StackTraceConfig,
};
pub use traceable::Traceable;
pub use type_registry::{RegisterableType, TypeId, TypeInfo};
pub use value::Value;
pub use value_conversion::{script_value_to_value, value_to_script_value, ValueConversion};

use std::sync::atomic::{AtomicBool, Ordering};

/// Global flag indicating if the runtime is initialized
static RUNTIME_INITIALIZED: AtomicBool = AtomicBool::new(false);

/// Initialize the Script runtime
///
/// This must be called before any Script code can execute.
/// Returns an error if the runtime is already initialized.
pub fn initialize() -> Result<()> {
    if RUNTIME_INITIALIZED.swap(true, Ordering::SeqCst) {
        return Err(RuntimeError::AlreadyInitialized);
    }

    // Initialize subsystems
    profiler::initialize();
    type_registry::initialize();

    // Initialize security systems first
    let security_config = SecurityConfig::default();
    security::initialize_security_monitor(security_config).map_err(|e| {
        RuntimeError::InvalidOperation(format!("Security initialization failed: {e}"))
    })?;

    safe_gc::initialize_secure_gc().map_err(|e| {
        RuntimeError::CycleDetectionFailed(format!("Secure GC initialization failed: {e}"))
    })?;

    gc::initialize()
        .map_err(|e| RuntimeError::InvalidOperation(format!("GC initialization failed: {e}")))?;
    panic::initialize();
    recovery::initialize_state_recovery();

    // Initialize Tokio runtime bridge
    async_tokio_bridge::init_global_runtime().map_err(|e| {
        RuntimeError::InvalidOperation(format!("Tokio runtime initialization failed: {e}"))
    })?;

    // Initialize stack trace tracking
    stack_trace::initialize_stack_tracker().map_err(|e| {
        RuntimeError::InvalidOperation(format!("Stack tracker initialization failed: {e}"))
    })?;

    Ok(())
}

/// Shutdown the Script runtime
///
/// This should be called when the Script program exits to ensure
/// proper cleanup of resources.
pub fn shutdown() -> Result<()> {
    if !RUNTIME_INITIALIZED.swap(false, Ordering::SeqCst) {
        return Err(RuntimeError::NotInitialized);
    }

    // Shutdown subsystems in reverse order
    recovery::shutdown_state_recovery();
    panic::shutdown();
    gc::shutdown().unwrap_or_else(|e| eprintln!("Warning: GC shutdown failed: {e}"));
    type_registry::shutdown();
    profiler::shutdown();

    Ok(())
}

/// Check if the runtime is initialized
pub fn is_initialized() -> bool {
    RUNTIME_INITIALIZED.load(Ordering::SeqCst)
}

/// Runtime error types
#[derive(Debug, Clone, PartialEq)]
pub enum RuntimeError {
    /// Runtime is already initialized
    AlreadyInitialized,
    /// Runtime is not initialized
    NotInitialized,
    /// Memory allocation failed
    AllocationFailed(String),
    /// Cycle detection failed
    CycleDetectionFailed(String),
    /// Panic occurred with stack trace
    Panic(String),
    /// Runtime error with stack trace
    RuntimeErrorWithTrace { message: String, trace: StackTrace },
    /// Invalid operation
    InvalidOperation(String),
}

impl std::fmt::Display for RuntimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RuntimeError::AlreadyInitialized => write!(f, "Runtime is already initialized"),
            RuntimeError::NotInitialized => write!(f, "Runtime is not initialized"),
            RuntimeError::AllocationFailed(msg) => write!(f, "Allocation failed: {}", msg),
            RuntimeError::CycleDetectionFailed(msg) => write!(f, "Cycle detection failed: {}", msg),
            RuntimeError::Panic(msg) => write!(f, "Panic: {}", msg),
            RuntimeError::RuntimeErrorWithTrace { message, trace } => {
                write!(f, "Runtime error: {}\n{}", message, trace.format_trace())
            }
            RuntimeError::InvalidOperation(msg) => write!(f, "Invalid operation: {}", msg),
        }
    }
}

impl std::error::Error for RuntimeError {}

/// Result type for runtime operations
pub type Result<T> = std::result::Result<T, RuntimeError>;

#[cfg(test)]
mod tests;

#[cfg(test)]
mod unit_tests {
    use super::*;

    #[test]
    fn test_runtime_lifecycle() {
        // Ensure runtime is not initialized
        if is_initialized() {
            shutdown().unwrap();
        }

        // Test initialization
        assert!(!is_initialized());
        assert!(initialize().is_ok());
        assert!(is_initialized());

        // Test double initialization
        assert_eq!(initialize().unwrap_err(), RuntimeError::AlreadyInitialized);

        // Test shutdown
        assert!(shutdown().is_ok());
        assert!(!is_initialized());

        // Test double shutdown
        assert_eq!(shutdown().unwrap_err(), RuntimeError::NotInitialized);
    }
}
