//! Runtime system for the Script programming language
//!
//! This module provides the core runtime functionality including:
//! - Reference counting memory management with cycle detection
//! - Runtime initialization and shutdown
//! - Panic handling with stack traces
//! - Memory profiling and leak detection
//!
//! The runtime is designed to be thread-safe for future actor model support
//! and integrates with the code generated by the IR system.

pub mod async_runtime;
pub mod async_runtime_secure;
pub mod async_ffi;
pub mod async_resource_limits;
pub mod core;
pub mod gc;
pub mod panic;
pub mod profiler;
pub mod rc;
pub mod safe_gc;
pub mod resource_limits;
pub mod scheduler;
pub mod security;
pub mod traceable;
pub mod type_registry;
pub mod value;

pub use async_runtime::{BoxedFuture, Executor, ScriptFuture, TaskId, Timer};
pub use core::{Runtime, RuntimeConfig};
pub use gc::CycleCollector;
pub use panic::{PanicHandler, StackTrace};
pub use profiler::{AllocationStats, MemoryProfiler};
pub use rc::{ScriptRc, ScriptWeak};
pub use resource_limits::{ResourceLimits, ResourceMonitor, ResourceViolation};
pub use safe_gc::{SecureCycleCollector, GcSecurityConfig, SecurityError as GcSecurityError};
pub use scheduler::{Scheduler, Task};
pub use security::{SecurityConfig, SecurityEvent, SecurityEventType, SecurityMonitor};
pub use traceable::Traceable;
pub use type_registry::{RegisterableType, TypeId, TypeInfo};
pub use value::Value;

use std::sync::atomic::{AtomicBool, Ordering};

/// Global flag indicating if the runtime is initialized
static RUNTIME_INITIALIZED: AtomicBool = AtomicBool::new(false);

/// Initialize the Script runtime
///
/// This must be called before any Script code can execute.
/// Returns an error if the runtime is already initialized.
pub fn initialize() -> Result<()> {
    if RUNTIME_INITIALIZED.swap(true, Ordering::SeqCst) {
        return Err(RuntimeError::AlreadyInitialized);
    }

    // Initialize subsystems
    profiler::initialize();
    type_registry::initialize();
    
    // Initialize security systems first
    let security_config = SecurityConfig::default();
    security::initialize_security_monitor(security_config)
        .map_err(|e| RuntimeError::InvalidOperation(format!("Security initialization failed: {}", e)))?;
    
    safe_gc::initialize_secure_gc()
        .map_err(|e| RuntimeError::CycleDetectionFailed(format!("Secure GC initialization failed: {}", e)))?;
    
    gc::initialize();
    panic::initialize();

    Ok(())
}

/// Shutdown the Script runtime
///
/// This should be called when the Script program exits to ensure
/// proper cleanup of resources.
pub fn shutdown() -> Result<()> {
    if !RUNTIME_INITIALIZED.swap(false, Ordering::SeqCst) {
        return Err(RuntimeError::NotInitialized);
    }

    // Shutdown subsystems in reverse order
    panic::shutdown();
    gc::shutdown();
    type_registry::shutdown();
    profiler::shutdown();

    Ok(())
}

/// Check if the runtime is initialized
pub fn is_initialized() -> bool {
    RUNTIME_INITIALIZED.load(Ordering::SeqCst)
}

/// Runtime error types
#[derive(Debug, Clone, PartialEq)]
pub enum RuntimeError {
    /// Runtime is already initialized
    AlreadyInitialized,
    /// Runtime is not initialized
    NotInitialized,
    /// Memory allocation failed
    AllocationFailed(String),
    /// Cycle detection failed
    CycleDetectionFailed(String),
    /// Panic occurred
    Panic(String),
    /// Invalid operation
    InvalidOperation(String),
}

impl std::fmt::Display for RuntimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RuntimeError::AlreadyInitialized => write!(f, "Runtime is already initialized"),
            RuntimeError::NotInitialized => write!(f, "Runtime is not initialized"),
            RuntimeError::AllocationFailed(msg) => write!(f, "Allocation failed: {}", msg),
            RuntimeError::CycleDetectionFailed(msg) => write!(f, "Cycle detection failed: {}", msg),
            RuntimeError::Panic(msg) => write!(f, "Panic: {}", msg),
            RuntimeError::InvalidOperation(msg) => write!(f, "Invalid operation: {}", msg),
        }
    }
}

impl std::error::Error for RuntimeError {}

/// Result type for runtime operations
pub type Result<T> = std::result::Result<T, RuntimeError>;

#[cfg(test)]
mod tests;

#[cfg(test)]
mod unit_tests {
    use super::*;

    #[test]
    fn test_runtime_lifecycle() {
        // Ensure runtime is not initialized
        if is_initialized() {
            shutdown().unwrap();
        }

        // Test initialization
        assert!(!is_initialized());
        assert!(initialize().is_ok());
        assert!(is_initialized());

        // Test double initialization
        assert_eq!(initialize().unwrap_err(), RuntimeError::AlreadyInitialized);

        // Test shutdown
        assert!(shutdown().is_ok());
        assert!(!is_initialized());

        // Test double shutdown
        assert_eq!(shutdown().unwrap_err(), RuntimeError::NotInitialized);
    }
}
